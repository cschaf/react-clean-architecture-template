# Contributing Guide

Vielen Dank f√ºr Ihr Interesse, zum React Clean Architecture Template beizutragen! Diese Anleitung hilft Ihnen dabei, effektiv zu diesem Projekt beizutragen.

## üìã Inhaltsverzeichnis

- [Code of Conduct](#code-of-conduct)
- [Entwicklungsumgebung Setup](#entwicklungsumgebung-setup)
- [Architektur-Prinzipien](#architektur-prinzipien)
- [Contribution Workflow](#contribution-workflow)
- [Code-Standards](#code-standards)
- [Testing Guidelines](#testing-guidelines)
- [Pull Request Prozess](#pull-request-prozess)
- [Release Prozess](#release-prozess)

## Code of Conduct

Dieses Projekt folgt einem Code of Conduct. Durch Ihre Teilnahme stimmen Sie zu, respektvoll und konstruktiv mit anderen Contributors umzugehen.

## Entwicklungsumgebung Setup

### Voraussetzungen

- **Node.js**: Version 18 oder h√∂her
- **pnpm**: Bevorzugter Package Manager
- **Git**: F√ºr Versionskontrolle
- **VS Code/Cursor**: Empfohlene IDEs mit TypeScript-Support

### Projekt Setup

```bash\n# 1. Repository forken und klonen\ngit clone https://github.com/your-username/react-clean-architecture-template.git\ncd react-clean-architecture-template\n\n# 2. Dependencies installieren\npnpm install\n\n# 3. Entwicklungsserver starten\npnpm dev\n\n# 4. Tests ausf√ºhren\npnpm test\n\n# 5. Type-Checking\npnpm type-check\n\n# 6. Linting\npnpm lint\n```\n\n### Entwicklungstools\n\n```bash\n# Code-Formatierung\npnpm format\n\n# Test Coverage\npnpm test:coverage\n\n# Build f√ºr Production\npnpm build\n\n# Preview Production Build\npnpm preview\n```\n\n## Architektur-Prinzipien\n\n### Clean Architecture Layer\n\nDas Projekt folgt strikten Clean Architecture-Prinzipien:\n\n```\nsrc/\n‚îú‚îÄ‚îÄ domain/                 # Gesch√§ftslogik (keine externen Dependencies)\n‚îú‚îÄ‚îÄ infrastructure/         # Externe Services (implementiert Domain Interfaces)\n‚îú‚îÄ‚îÄ presentation/           # UI Layer (React Components)\n‚îú‚îÄ‚îÄ app/                   # Application Layer (DI, Router, Provider)\n‚îî‚îÄ‚îÄ shared/                # Geteilte Utilities und Types\n```\n\n### Dependency Rules (ZWINGEND)\n\n‚úÖ **Erlaubte Dependencies:**\n- `presentation/` ‚Üí `domain/`\n- `infrastructure/` ‚Üí `domain/`  \n- `app/` ‚Üí alle Layer\n- `domain/` ‚Üí `shared/` (nur)\n\n‚ùå **Verbotene Dependencies:**\n- `domain/` ‚Üí `infrastructure/`\n- `domain/` ‚Üí `presentation/`\n- `domain/` ‚Üí `app/`\n\n### SOLID-Prinzipien\n\n1. **Single Responsibility**: Eine Klasse = ein √Ñnderungsgrund\n2. **Open/Closed**: Offen f√ºr Erweiterung, geschlossen f√ºr Modifikation\n3. **Liskov Substitution**: Implementierungen sind austauschbar\n4. **Interface Segregation**: Kleine, fokussierte Interfaces\n5. **Dependency Inversion**: Abh√§ngigkeiten zu Abstraktionen\n\n## Contribution Workflow\n\n### 1. Issue erstellen oder √ºbernehmen\n\n- Pr√ºfen Sie bestehende Issues\n- Erstellen Sie ein neues Issue f√ºr Bugs oder Features\n- Warten Sie auf Feedback vor gr√∂√üeren √Ñnderungen\n- Verwenden Sie Issue-Templates\n\n### 2. Branch erstellen\n\n```bash\n# Feature Branch\ngit checkout -b feature/user-authentication\n\n# Bug Fix Branch  \ngit checkout -b fix/validation-error-handling\n\n# Documentation Branch\ngit checkout -b docs/api-documentation\n```\n\n### 3. Entwicklung\n\n- Folgen Sie den Code-Standards\n- Implementieren Sie Tests\n- Dokumentieren Sie Ihre √Ñnderungen\n- Committen Sie h√§ufig mit aussagekr√§ftigen Messages\n\n### 4. Testing\n\n```bash\n# Alle Tests ausf√ºhren\npnpm test\n\n# Tests mit Coverage\npnpm test:coverage\n\n# Type-Checking\npnpm type-check\n\n# Build-Test\npnpm build\n```\n\n## Code-Standards\n\n### TypeScript Guidelines\n\n```typescript\n// ‚úÖ Gut: Explizite Typisierung\ninterface UserProps {\n  readonly id: string\n  readonly email: string\n  readonly isActive: boolean\n}\n\n// ‚ùå Schlecht: Implizite any\ninterface UserProps {\n  id\n  email\n  isActive\n}\n\n// ‚úÖ Gut: Result Pattern\ntype Result<T, E = Error> = \n  | { readonly success: true; readonly data: T }\n  | { readonly success: false; readonly error: E }\n\n// ‚ùå Schlecht: Exception-based Error Handling\nfunction riskyOperation(): User {\n  throw new Error('Something went wrong')\n}\n```\n\n### Entity Pattern\n\n```typescript\n// ‚úÖ Korrekte Entity-Implementierung\nexport class User implements BaseEntity {\n  private constructor(private readonly props: UserProps) {\n    this.validateBusinessRules()\n  }\n\n  public static create(props: CreateUserProps): User {\n    return new User({\n      ...props,\n      id: crypto.randomUUID(),\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    })\n  }\n\n  public static fromPersistence(props: UserProps): User {\n    return new User(props)\n  }\n\n  // Immutable Updates\n  public updateEmail(email: string): User {\n    return new User({\n      ...this.props,\n      email,\n      updatedAt: new Date(),\n    })\n  }\n\n  // Business Logic Methods\n  public canPerformAction(action: string): boolean {\n    return this.props.isActive && this.hasPermission(action)\n  }\n\n  // Getter f√ºr Properties\n  public get email(): string {\n    return this.props.email\n  }\n\n  private validateBusinessRules(): void {\n    if (!this.props.email.includes('@')) {\n      throw new ValidationError('Invalid email format', 'email')\n    }\n  }\n}\n```\n\n### Use Case Pattern\n\n```typescript\n// ‚úÖ Korrekte Use Case-Implementierung\nexport class CreateUserUseCase {\n  constructor(\n    private readonly userRepository: UserRepository,\n    private readonly passwordHasher: PasswordHasher,\n    private readonly emailService: EmailService\n  ) {}\n\n  public async execute(input: CreateUserInput): Promise<Result<CreateUserOutput>> {\n    try {\n      // 1. Input Validation\n      const validation = createUserSchema.safeParse(input)\n      if (!validation.success) {\n        return { \n          success: false, \n          error: new ValidationError('Invalid input', validation.error.message) \n        }\n      }\n\n      // 2. Business Rules\n      const emailExists = await this.userRepository.emailExists(input.email)\n      if (emailExists.data) {\n        return { \n          success: false, \n          error: new DomainError('Email already exists', 'EMAIL_EXISTS') \n        }\n      }\n\n      // 3. Entity Creation\n      const user = User.create(input)\n      \n      // 4. Persistence\n      const saveResult = await this.userRepository.save(user)\n      if (!saveResult.success) {\n        return saveResult\n      }\n\n      // 5. Side Effects (Fire and Forget)\n      this.executeAsyncSideEffects(user)\n\n      return { success: true, data: { user: saveResult.data } }\n    } catch (error) {\n      return { \n        success: false, \n        error: error instanceof Error ? error : new Error('Unknown error') \n      }\n    }\n  }\n\n  private async executeAsyncSideEffects(user: User): Promise<void> {\n    try {\n      await Promise.allSettled([\n        this.emailService.sendWelcomeEmail(user.email, user.firstName),\n        // Weitere Side Effects\n      ])\n    } catch (error) {\n      console.error('Side effect failed:', error)\n    }\n  }\n}\n```\n\n### Component Guidelines\n\n```typescript\n// ‚úÖ Smart Component Pattern\nexport function UserManagementPage(): JSX.Element {\n  const createUserUseCase = useCreateUserUseCase()\n  const listUsersUseCase = useListUsersUseCase()\n  \n  const [users, setUsers] = useState<User[]>([])\n  const [loading, setLoading] = useState(true)\n  const [error, setError] = useState<string | null>(null)\n\n  const handleCreateUser = useCallback(async (userData: CreateUserInput) => {\n    const result = await createUserUseCase.execute(userData)\n    \n    if (result.success) {\n      toast.success('Benutzer erfolgreich erstellt')\n      await loadUsers()\n    } else {\n      toast.error(result.error.message)\n    }\n  }, [createUserUseCase])\n\n  // ... weitere Implementierung\n\n  return (\n    <PageContainer title=\"Benutzerverwaltung\">\n      <UserManagementView \n        users={users}\n        loading={loading}\n        error={error}\n        onCreateUser={handleCreateUser}\n      />\n    </PageContainer>\n  )\n}\n\n// ‚úÖ Dumb Component Pattern\ninterface UserManagementViewProps {\n  readonly users: User[]\n  readonly loading: boolean\n  readonly error: string | null\n  readonly onCreateUser: (data: CreateUserInput) => Promise<void>\n}\n\nexport function UserManagementView({ \n  users, \n  loading, \n  error, \n  onCreateUser \n}: UserManagementViewProps): JSX.Element {\n  if (loading) return <LoadingSpinner />\n  if (error) return <ErrorMessage message={error} />\n\n  return (\n    <div className=\"space-y-6\">\n      <div className=\"flex justify-between items-center\">\n        <h2 className=\"text-xl font-semibold\">Benutzer ({users.length})</h2>\n        <CreateUserDialog onSubmit={onCreateUser} />\n      </div>\n      \n      <UserTable users={users} />\n    </div>\n  )\n}\n```\n\n### Import Guidelines\n\n```typescript\n// ‚úÖ Korrekte Imports\nimport { User } from '@/domain/entities'\nimport { CreateUserUseCase } from '@/domain/use-cases'\nimport { UserApiRepository } from '@/infrastructure/api'\nimport { PageContainer } from '@/presentation/layouts'\nimport { cn, formatDate } from '@/shared/utils'\n\n// ‚ùå Inkorrekte Imports\nimport { User } from '../../../domain/entities/User'\nimport { HttpClient } from '@/infrastructure/api' // In Domain Layer\n```\n\n### Naming Conventions\n\n- **Entities**: PascalCase, Singular (z.B. `User`, `Product`)\n- **Use Cases**: PascalCase + \"UseCase\" (z.B. `CreateUserUseCase`)\n- **Repositories**: PascalCase + \"Repository\" (z.B. `UserRepository`)\n- **Components**: PascalCase (z.B. `UserCard`, `LoginForm`)\n- **Hooks**: camelCase + \"use\" prefix (z.B. `useCreateUserUseCase`)\n- **Constants**: SCREAMING_SNAKE_CASE (z.B. `API_BASE_URL`)\n\n## Testing Guidelines\n\n### Test Structure\n\n```\ntests/\n‚îú‚îÄ‚îÄ unit/                   # Domain Logic Tests\n‚îÇ   ‚îú‚îÄ‚îÄ entities/\n‚îÇ   ‚îî‚îÄ‚îÄ use-cases/\n‚îú‚îÄ‚îÄ integration/            # Repository/API Tests\n‚îÇ   ‚îî‚îÄ‚îÄ repositories/\n‚îú‚îÄ‚îÄ component/              # React Component Tests\n‚îÇ   ‚îú‚îÄ‚îÄ pages/\n‚îÇ   ‚îî‚îÄ‚îÄ components/\n‚îî‚îÄ‚îÄ e2e/                   # End-to-End Tests\n    ‚îî‚îÄ‚îÄ user-flows/\n```\n\n### Entity Tests\n\n```typescript\ndescribe('User Entity', () => {\n  describe('creation', () => {\n    it('should create user with valid data', () => {\n      const user = User.create({\n        email: 'john@example.com',\n        firstName: 'John',\n        lastName: 'Doe'\n      })\n      \n      expect(user.fullName).toBe('John Doe')\n      expect(user.email).toBe('john@example.com')\n      expect(user.isActive).toBe(true)\n    })\n\n    it('should validate email format on creation', () => {\n      expect(() => User.create({\n        email: 'invalid-email',\n        firstName: 'John',\n        lastName: 'Doe'\n      })).toThrow(ValidationError)\n    })\n  })\n\n  describe('business methods', () => {\n    it('should allow actions for active users', () => {\n      const user = User.create(validUserData)\n      \n      expect(user.canPerformAction('READ')).toBe(true)\n    })\n\n    it('should deny actions for inactive users', () => {\n      const user = User.create(validUserData).deactivate()\n      \n      expect(user.canPerformAction('READ')).toBe(false)\n    })\n  })\n\n  describe('immutability', () => {\n    it('should create new instance on updates', () => {\n      const originalUser = User.create(validUserData)\n      const updatedUser = originalUser.updateEmail('new@example.com')\n      \n      expect(updatedUser).not.toBe(originalUser)\n      expect(updatedUser.email).toBe('new@example.com')\n      expect(originalUser.email).toBe('john@example.com')\n    })\n  })\n})\n```\n\n### Use Case Tests\n\n```typescript\ndescribe('CreateUserUseCase', () => {\n  let useCase: CreateUserUseCase\n  let mockUserRepository: jest.Mocked<UserRepository>\n  let mockPasswordHasher: jest.Mocked<PasswordHasher>\n  let mockEmailService: jest.Mocked<EmailService>\n\n  beforeEach(() => {\n    mockUserRepository = createMockUserRepository()\n    mockPasswordHasher = createMockPasswordHasher()\n    mockEmailService = createMockEmailService()\n    \n    useCase = new CreateUserUseCase(\n      mockUserRepository,\n      mockPasswordHasher,\n      mockEmailService\n    )\n  })\n\n  describe('successful creation', () => {\n    it('should create user with valid input', async () => {\n      // Arrange\n      const input = {\n        email: 'new@example.com',\n        firstName: 'John',\n        lastName: 'Doe',\n        password: 'securePassword123'\n      }\n      \n      mockUserRepository.emailExists.mockResolvedValue({ success: true, data: false })\n      mockUserRepository.save.mockResolvedValue({ \n        success: true, \n        data: expect.any(User) \n      })\n      mockPasswordHasher.hash.mockResolvedValue('hashedPassword')\n\n      // Act\n      const result = await useCase.execute(input)\n\n      // Assert\n      expect(result.success).toBe(true)\n      expect(mockUserRepository.save).toHaveBeenCalledWith(expect.any(User))\n      expect(mockEmailService.sendWelcomeEmail).toHaveBeenCalledWith(\n        'new@example.com',\n        'John'\n      )\n    })\n  })\n\n  describe('validation errors', () => {\n    it('should reject invalid email format', async () => {\n      const input = {\n        email: 'invalid-email',\n        firstName: 'John',\n        lastName: 'Doe',\n        password: 'password123'\n      }\n\n      const result = await useCase.execute(input)\n\n      expect(result.success).toBe(false)\n      expect(result.error).toBeInstanceOf(ValidationError)\n    })\n\n    it('should reject duplicate email', async () => {\n      const input = validCreateUserInput\n      \n      mockUserRepository.emailExists.mockResolvedValue({ success: true, data: true })\n\n      const result = await useCase.execute(input)\n\n      expect(result.success).toBe(false)\n      expect(result.error).toBeInstanceOf(DomainError)\n      expect(mockUserRepository.save).not.toHaveBeenCalled()\n    })\n  })\n})\n```\n\n### Component Tests\n\n```typescript\ndescribe('UserManagementPage', () => {\n  const mockDependencies = createTestDependencies({\n    listUsersUseCase: createMockListUsersUseCase({\n      execute: jest.fn().mockResolvedValue({\n        success: true,\n        data: { users: { data: [mockUser1, mockUser2] } }\n      })\n    }),\n    createUserUseCase: createMockCreateUserUseCase()\n  })\n\n  beforeEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('should display user list after loading', async () => {\n    render(\n      <DependencyProvider overrides={mockDependencies}>\n        <UserManagementPage />\n      </DependencyProvider>\n    )\n\n    expect(screen.getByText('Lade...')).toBeInTheDocument()\n\n    await waitFor(() => {\n      expect(screen.getByText('John Doe')).toBeInTheDocument()\n      expect(screen.getByText('Jane Smith')).toBeInTheDocument()\n    })\n\n    expect(screen.queryByText('Lade...')).not.toBeInTheDocument()\n  })\n\n  it('should handle user creation', async () => {\n    const user = userEvent.setup()\n    \n    render(\n      <DependencyProvider overrides={mockDependencies}>\n        <UserManagementPage />\n      </DependencyProvider>\n    )\n\n    // Warten bis Komponente geladen ist\n    await waitFor(() => {\n      expect(screen.getByRole('button', { name: /neuer benutzer/i })).toBeInTheDocument()\n    })\n\n    // Dialog √∂ffnen\n    await user.click(screen.getByRole('button', { name: /neuer benutzer/i }))\n    \n    // Formular ausf√ºllen\n    await user.type(screen.getByLabelText(/email/i), 'new@example.com')\n    await user.type(screen.getByLabelText(/vorname/i), 'New')\n    await user.type(screen.getByLabelText(/nachname/i), 'User')\n    await user.type(screen.getByLabelText(/passwort/i), 'password123')\n    \n    // Absenden\n    await user.click(screen.getByRole('button', { name: /erstellen/i }))\n\n    expect(mockDependencies.createUserUseCase.execute).toHaveBeenCalledWith({\n      email: 'new@example.com',\n      firstName: 'New',\n      lastName: 'User',\n      password: 'password123'\n    })\n  })\n\n  it('should display error message on creation failure', async () => {\n    mockDependencies.createUserUseCase.execute.mockResolvedValue({\n      success: false,\n      error: new Error('Email bereits vorhanden')\n    })\n\n    const user = userEvent.setup()\n    \n    render(\n      <DependencyProvider overrides={mockDependencies}>\n        <UserManagementPage />\n      </DependencyProvider>\n    )\n\n    // ... User Creation Schritte ...\n\n    await waitFor(() => {\n      expect(screen.getByText('Email bereits vorhanden')).toBeInTheDocument()\n    })\n  })\n})\n```\n\n### Mock Factories\n\n```typescript\n// Test Utilities\nexport function createMockUserRepository(): jest.Mocked<UserRepository> {\n  return {\n    findById: jest.fn(),\n    findByEmail: jest.fn(),\n    save: jest.fn(),\n    emailExists: jest.fn(),\n  }\n}\n\nexport function createMockUser(overrides: Partial<UserProps> = {}): User {\n  return User.fromPersistence({\n    id: 'test-user-id',\n    email: 'test@example.com',\n    firstName: 'Test',\n    lastName: 'User',\n    isActive: true,\n    roles: ['user'],\n    createdAt: new Date('2023-01-01'),\n    updatedAt: new Date('2023-01-01'),\n    ...overrides\n  })\n}\n\nexport function createTestDependencies(overrides: Partial<Dependencies> = {}): Dependencies {\n  return {\n    userRepository: createMockUserRepository(),\n    createUserUseCase: createMockCreateUserUseCase(),\n    listUsersUseCase: createMockListUsersUseCase(),\n    ...overrides\n  }\n}\n```\n\n## Pull Request Prozess\n\n### PR Template\n\n```markdown\n## Beschreibung\n\nKurze Beschreibung der √Ñnderungen und warum sie notwendig sind.\n\n## Art der √Ñnderung\n\n- [ ] Bug Fix (nicht-brechende √Ñnderung, die ein Problem behebt)\n- [ ] Neues Feature (nicht-brechende √Ñnderung, die neue Funktionalit√§t hinzuf√ºgt)\n- [ ] Breaking Change (√Ñnderung, die bestehende Funktionalit√§t bricht)\n- [ ] Dokumentation (nur Dokumentations-Updates)\n- [ ] Refactoring (Code-Verbesserung ohne Funktions√§nderung)\n\n## Checklist\n\n- [ ] Code folgt den Coding Standards des Projekts\n- [ ] Self-Review durchgef√ºhrt\n- [ ] Code ist kommentiert, besonders in schwer verst√§ndlichen Bereichen\n- [ ] Entsprechende √Ñnderungen an der Dokumentation vorgenommen\n- [ ] √Ñnderungen generieren keine neuen Warnings\n- [ ] Tests hinzugef√ºgt, die beweisen, dass der Fix/das Feature funktioniert\n- [ ] Neue und bestehende Tests bestehen lokal\n- [ ] Clean Architecture Prinzipien eingehalten\n- [ ] TypeScript strict mode ohne Fehler\n\n## Tests\n\nBeschreiben Sie die Tests, die Sie ausgef√ºhrt haben:\n\n```bash\npnpm test\npnpm type-check  \npnpm build\n```\n\n## Screenshots (falls UI-√Ñnderungen)\n\n| Vorher | Nachher |\n|--------|--------|\n| ... | ... |\n\n## Zus√§tzlicher Kontext\n\nWeitere Informationen √ºber die Implementierung oder Designentscheidungen.\n```\n\n### Review Kriterien\n\n**Architektur:**\n- [ ] Layer-Dependencies korrekt (Domain ‚Üí Infrastructure verboten)\n- [ ] SOLID-Prinzipien befolgt\n- [ ] Dependency Injection korrekt implementiert\n- [ ] Result Pattern f√ºr Error Handling verwendet\n\n**Code Quality:**\n- [ ] TypeScript strict mode ohne Errors\n- [ ] Keine `any` Types\n- [ ] Readonly Properties wo m√∂glich\n- [ ] Aussagekr√§ftige Namen\n- [ ] Code ist selbst-dokumentierend\n\n**Testing:**\n- [ ] Unit Tests f√ºr Business Logic\n- [ ] Integration Tests f√ºr API Layer\n- [ ] Component Tests f√ºr UI\n- [ ] Mindestens 80% Test Coverage\n\n**Performance:**\n- [ ] Lazy Loading implementiert wo sinnvoll\n- [ ] Memoization f√ºr teure Operationen\n- [ ] Bundle Size Impact ber√ºcksichtigt\n\n**Accessibility:**\n- [ ] ARIA Labels f√ºr interaktive Elemente\n- [ ] Semantisches HTML\n- [ ] Keyboard Navigation\n- [ ] Screen Reader Support\n\n## Release Prozess\n\n### Versioning\n\nWir folgen [Semantic Versioning](https://semver.org/):\n\n- **MAJOR**: Breaking Changes\n- **MINOR**: Neue Features (r√ºckw√§rtskompatibel)\n- **PATCH**: Bug Fixes (r√ºckw√§rtskompatibel)\n\n### Release Workflow\n\n1. **Feature Development**: Feature-Branches ‚Üí `develop`\n2. **Release Preparation**: `develop` ‚Üí `release/x.y.z`\n3. **Release**: `release/x.y.z` ‚Üí `main` + Tag\n4. **Hotfixes**: `hotfix/x.y.z` ‚Üí `main` + `develop`\n\n### Release Checklist\n\n- [ ] Alle Tests bestehen\n- [ ] Documentation aktualisiert\n- [ ] CHANGELOG.md aktualisiert\n- [ ] Version in package.json aktualisiert\n- [ ] Release Notes erstellt\n- [ ] Migration Guide (falls Breaking Changes)\n\n## H√§ufige Probleme\n\n### Build Errors\n\n```bash\n# TypeScript Errors beheben\npnpm type-check\n\n# Dependencies Probleme\nrm -rf node_modules pnpm-lock.yaml\npnpm install\n\n# Cache Probleme\npnpm build --clean\n```\n\n### Test Failures\n\n```bash\n# Einzelnen Test debuggen\npnpm test -- --testNamePattern=\"specific test\"\n\n# Test Coverage pr√ºfen\npnpm test:coverage\n\n# Test UI f√ºr Debugging\npnpm test:ui\n```\n\n### Dependency Issues\n\n```bash\n# Peer Dependency Warnings\npnpm install --save-peer <package>\n\n# Dependency Audit\npnpm audit\npnpm audit --fix\n```\n\n## Hilfe und Support\n\n- **GitHub Issues**: Bug Reports und Feature Requests\n- **GitHub Discussions**: Allgemeine Fragen und Diskussionen\n- **Documentation**: Siehe `/docs` Ordner\n- **Architecture Guide**: [ARCHITECTURE.md](./ARCHITECTURE.md)\n\n---\n\n**Vielen Dank f√ºr Ihren Beitrag zum React Clean Architecture Template! üöÄ**\n"